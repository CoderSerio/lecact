(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.index = global.index || {}, global.index.js = factory()));
})(this, (function () { 'use strict';

	const NoFlags = 0b00000001;
	const Placement = 0b00000010;
	const Update = 0b00000100;
	const ChildDeletion = 0b00001000;
	/**
	 * commit的三个子阶段中，处理 mutation
	 * 利用下面这个 mutation 掩码，只需要将 subtreeFlags 与之按位与运算一下，
	 * 就能知道是否存在这些副作用了
	 *
	 */
	const MutationMask = Placement | Update | ChildDeletion;

	/** 函数组件 */
	const FunctionComponent = 0;
	/** 项目挂载的根节点 */
	const HostRoot = 3;
	/**  原生的 HTML 标签 */
	const HostComponent = 5;
	/** 文本节点 */
	const HostText = 6;

	/** Fiber节点类型，上面挂了非常多属性。
	 *
	 * 注意区别于 FiberRootNode 类型——它的 current 属性指向了fiber树的根节点
	 *
	 * 构造 fiberNode 时，只需要传递三个参数：
	 * 1. workTag: fiberNode 可以支持的类型，比如 FunctionComponent 等
	 * 2. props: 属性
	 * 3. key: dddd
	 */
	class FiberNode {
	    type;
	    tag;
	    pendingProps;
	    key;
	    stateNode;
	    return;
	    sibling;
	    child;
	    index;
	    ref;
	    memorizedProps;
	    memorizedState;
	    alternate;
	    flags;
	    subtreeFlags;
	    updateQueue;
	    constructor(tag, pendingProps, key) {
	        // 以下是记录实例相关的属性
	        this.tag = tag;
	        /** diff的键 */
	        this.key = key;
	        // DOM
	        this.stateNode = null;
	        // 类型
	        this.type = null;
	        // 以下是记录树状关系结构相关的属性
	        // 父级节点
	        this.return = null;
	        // 右边的兄弟节点
	        this.sibling = null;
	        // 子节点
	        this.child = null;
	        // 子节点的下标
	        this.index = 0;
	        // 对自身的引用
	        this.ref = null;
	        // 以下是辅助作为工作单元相关的属性
	        // 工作单元刚开始的时候的props
	        this.pendingProps = pendingProps;
	        // 更新完了之后的 props
	        this.memorizedProps = null;
	        // 更新完了之后的 state
	        this.memorizedState = null;
	        // workInProgress 和 current 树的节点相互指向
	        this.alternate = null;
	        // 副作用标签
	        this.flags = NoFlags;
	        // 子树的副作用标签
	        this.subtreeFlags = NoFlags;
	        // 更新队列
	        this.updateQueue = null;
	    }
	}
	/**
	 * 用于切换 fiber 树的节点，具有一些重要的属性:
	 *
	 * 0. container: 在浏览器环境下 Container 就是 DOM 类型，这里做抽象是为了兼容更多环境
	 * 1. current: 指向 current fiber 树 的根节点（hostRootFiber）
	 * 2. finishedWork: 指向 workInProgress fiber 树 的根节点（hostRootFiber）
	 *
	 * 这里需要注意，fiber 树的跟节点（hostRootFiber）有一个 stateNode 可以访问 FiberRootNode
	 */
	class FiberRootNode {
	    container;
	    current;
	    finishedWork;
	    constructor(container, hostRootFiber) {
	        this.container = container;
	        // 相互指向对方
	        this.current = hostRootFiber;
	        hostRootFiber.stateNode = this;
	        this.finishedWork = null;
	    }
	}
	/**
	 * 传入当前的 current fiber 树根节点， 返回对应的 workInProgress fiber tree
	 */
	function createWorkInProgress(current, pendingProps) {
	    // workInProgress 的缩写
	    let wip;
	    return wip;
	}
	/** 根据 ReactElement 创建 fiber */
	function createFiberFromElement(elemenet) {
	    const { type, key, props } = elemenet;
	    // 默认是函数组件
	    let fiberTag = FunctionComponent;
	    if (typeof type === 'string') {
	        // 对于单个标签，像是 <div/> 这样的，类型就是 'div' 字符串
	        fiberTag = HostComponent;
	    }
	    else if (typeof type !== 'function' && true) {
	        console.warn('未定义的type类型', elemenet);
	    }
	    const fiber = new FiberNode(fiberTag, props, key);
	    fiber.type = type;
	    return fiber;
	}

	/**
	 * 创建一个 update 对象，
	 * 这个对象的核心是包含一个 action，也就是各种更新操作，比如useState等等
	 */
	function createUpdate(action) {
	    return {
	        action
	    };
	}
	/**
	 *  创建 updateQueue, 后续可以通过 enqueueUpdate 为队列增加 action
	 *
	 *	返回值的核心内容是 updateQueue.shared.pending， 为什么是 shared 呢？
	 * 	这是指在 current fiberNode 树 和 workInProgress fiberNode 树 之间去共享这一份数据
	 */
	function createUpdateQueue() {
	    return {
	        shared: {
	            pending: null
	        }
	    };
	}
	/**
	 * 为 updateQUeue 增加 update 对象的方法
	 */
	function enqueueUpdate(updateQueue, update) {
	    updateQueue.shared.pending = update;
	}
	/** 消耗 update 的方法，有两种情况：
	 * 1. baseState 为 1， update 为 2，那么 memorizedState 就是 2
	 * 2. baseState 为 1, update 为 (x) => 2 * x，那么memorizedState 就是 2 * x 即 2
	 *
	 * 返回值就是 memorizedState，也就是更新完成后的状态
	 */
	function processUpdateQueue(baseState, pendingUpdate) {
	    const result = {
	        memorizedState: baseState
	    };
	    if (pendingUpdate !== null) {
	        const action = pendingUpdate.action;
	        if (action instanceof Function) {
	            result.memorizedState = action(baseState);
	        }
	        else {
	            result.memorizedState = action;
	        }
	    }
	    return result;
	}

	const supportSymbol = typeof Symbol === 'function' && Symbol.for;
	const REACT_ELEMENT_TYPE = supportSymbol
	    ? Symbol.for('react.element')
	    : 0;

	/** 通用的子节点协调方法，内部创建了闭包，提供多个协调方法 */
	function ChildReconciler(shouldTrackEffects) {
	    /** 单节点协调 */
	    const reconcileSingleElement = (parentFiber, currentFiber, element) => {
	        const fiber = createFiberFromElement(element);
	        fiber.return = parentFiber;
	        return fiber;
	    };
	    /** 协调文本节点 */
	    const reconcileSingleTextNode = (parentFiber, currentFiber, content) => {
	        const fiber = new FiberNode(HostText, { content }, null);
	        fiber.return = parentFiber;
	        return fiber;
	    };
	    /** 插入节点
	     * 由于我们这里传入的 fiber 是 workInProgress FiberNode
	     * 所以 fiber.alternate 就是 current FiberNode
	     */
	    const placeSingleChild = (fiber) => {
	        if (shouldTrackEffects && fiber.alternate === null) {
	            // 由于操作类型是二进制表示的，这里需要把后面的几位全部取 1
	            fiber.flags |= Placement;
	        }
	        return fiber;
	    };
	    /** 相当于协调的 main 函数，判断不同的类型，选择不同的协调方法 */
	    return function reconcileChildrenFibers(parentFiber, currentFiber, newChild) {
	        if (typeof newChild === 'object' && newChild !== null) {
	            switch (newChild.$$typeof) {
	                case REACT_ELEMENT_TYPE:
	                    const newFiber = reconcileSingleElement(parentFiber, currentFiber, newChild);
	                    return placeSingleChild(newFiber);
	                default:
	                    {
	                        console.warn('未实现的reconcile类型', newChild);
	                    }
	                    break;
	            }
	        }
	        if (typeof newChild === 'string' || typeof newChild === 'number') {
	            const newFiber = reconcileSingleTextNode(parentFiber, currentFiber, newChild);
	            return placeSingleChild(newFiber);
	        }
	        {
	            console.warn('未实现的类型', newChild);
	        }
	        return null;
	    };
	}
	/** 和 mountChildFibers 类似，但是会追踪副作用 */
	const reconcileChildFibers = ChildReconciler(true);
	/** 和 reconcileChildFibers 类似，但是不会追踪副作用 */
	const mountChildFibers = ChildReconciler(false);

	function updateHostRoot(wip) {
	    const baseState = wip.memorizedState;
	    const updateQueue = wip.updateQueue;
	    const pending = updateQueue.shared.pending;
	    updateQueue.shared.pending = null;
	    processUpdateQueue(baseState, pending);
	    // 获取子 ReactElement 和 子 fiberNode 并进行对比，然后生成新的 fiberNode
	    const nextChildren = wip.memorizedState;
	    reconcileChildren(wip, nextChildren);
	    return wip.child;
	}
	// HostComponent 中是无法触发更新的
	function updateHostComponent(wip) {
	    wip.pendingProps;
	    const nextChildren = wip.memorizedState;
	    reconcileChildren(wip, nextChildren);
	    return wip.child;
	}
	/**
	 * 协调子节点，分为两种类型，一种是 mount 另一种是 update
	 *
	 * 这里针对 mount 流程存在一种优化策略，具体是内容是做 DOM 离线化，
	 * 尽可能把多次 Placement 操作合并（ 这些Placement对应的节点构成了一个树，直接插入根节点即可）
	 *
	 * 一个比较有意思的事情是，在首屏渲染时， 毫无疑问 App 组件会走 mount 流程，
	 * 然而——hostRootFiber 比较特殊，它在创建的时候就已经存在存在对应的 workInProgress fiberNode 了，
	 * 所以它会走 update 流程
	 */
	function reconcileChildren(wip, children) {
	    const current = wip.alternate;
	    if (current !== null) {
	        // 存在 current fiberNode 树，是 update 流程
	        // 不会存在大量的插入操作
	        wip.child = reconcileChildFibers(wip, current?.child, children);
	    }
	    else {
	        // 不存在， 则是 mount 流程
	        // 存在大量的插入操作
	        wip.child = mountChildFibers(wip, null, children);
	    }
	    return null;
	}
	/** 递归消费JSX的 递 阶段，需要做两件事：
	 *
	 * 1. 比较节点的 ReactElement 和 FiberNode, 计算最新值
	 * 2. 返回 子fiberNode
	 */
	function beginWork(wip) {
	    // 比较，然后返回子 fiberNode
	    switch (wip.tag) {
	        case HostRoot:
	            return updateHostRoot(wip);
	        case HostComponent:
	            return updateHostComponent(wip);
	        case HostText:
	            return null;
	        // return updateHostText(wip);
	        default:
	            {
	                console.warn('benginWork，未实现的类型！');
	            }
	            break;
	    }
	    return null;
	}

	/** 创建 DOM */
	const createInstance = (type) => {
	    // TODO: 处理props
	    const element = document.createElement(type);
	    return element;
	};
	const appendInitialChild = (parent, child) => {
	    parent.appendChild(child);
	};
	const appendChildToContainer = (child, container) => {
	    container.appendChild(child);
	};
	const createTextInstance = (content) => {
	    return document.createTextNode(content);
	};

	/** 下一个需要执行 Effect 的**节点**
	 *  注意是节点，只是名字取得比较奇怪
	 */
	let nextEffect = null;
	/** 真正执行插入节点 */
	const appendPlacementNodeIntoContainer = (finishedWork, hostParent) => {
	    // 我们插入的节点不可能是 HostRoot
	    if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
	        appendChildToContainer(finishedWork.stateNode, hostParent);
	        return;
	    }
	    const child = finishedWork.child;
	    if (child !== null) {
	        appendPlacementNodeIntoContainer(child, hostParent);
	        let sibling = child.sibling;
	        while (sibling !== null) {
	            appendPlacementNodeIntoContainer(sibling, hostParent);
	            sibling = sibling.sibling;
	        }
	    }
	};
	/** 获取原生的父级 DOM 节点
	 *  主要处理两种情况
	 */
	const getHostParent = (fiber) => {
	    let parent = fiber.return;
	    while (parent) {
	        const parentTag = parent.tag;
	        if (parentTag === HostComponent) {
	            return parent.stateNode;
	        }
	        if (parentTag === HostRoot) {
	            return parent.stateNode.container;
	        }
	        parent = parent.return;
	    }
	    {
	        console.warn('获取hostParent失败');
	    }
	};
	/** 处理 Placement，插入操作 */
	const commitPlacement = (finishedWork) => {
	    //
	    {
	        console.log('执行Placement操作', finishedWork);
	    }
	    /** 原生父级 DOM */
	    const hostParent = getHostParent(finishedWork);
	    if (hostParent !== null) {
	        appendPlacementNodeIntoContainer(finishedWork, hostParent);
	    }
	};
	/** 具体地开始处理 MutationMask 中的每一种 */
	const commitMutationEffectsOnFiber = (finishedWork) => {
	    const flags = finishedWork.flags;
	    if ((flags & Placement) !== NoFlags) {
	        commitPlacement(finishedWork);
	        // 将已经被处理的状态移除掉
	        finishedWork.flags &= ~Placement;
	    }
	    // TODO: 同样的方式判断其他几个 effect
	};
	const commitMutationEffects = (finishedWork) => {
	    nextEffect = finishedWork;
	    while (nextEffect !== null) {
	        const child = nextEffect.child;
	        if ((nextEffect.subtreeFlags & MutationMask) !== NoFlags &&
	            child !== null) {
	            nextEffect = child;
	        }
	        else {
	            // 找到底了 或者 不包含 MutationMask，
	            // 那么处理一下 effect 然后回到上一层
	            while (nextEffect !== null) {
	                commitMutationEffectsOnFiber(nextEffect);
	                const sibling = nextEffect.sibling;
	                if (sibling !== null) {
	                    nextEffect = sibling;
	                    // 记住nextEffect是全局变量，这里break之后继续找它的子节点——DFS
	                    break;
	                }
	                nextEffect = nextEffect.return;
	            }
	        }
	    }
	};

	/**
	 * 构建一个离屏的 DOM 树，将其插入 parent 中
	 *
	 * 这里做了一个优化：插入n个单节点 -> 组合成树插入一次
	 *
	 * 向下和向右(找兄弟节点)遍历，
	 * 然后同时不断地建立 return 和 sibling 关系
	 */
	function appendAllChildren(parent, wip) {
	    // 我们要插入的是节点的child
	    // 因为节点本身长这样： <App><div>没错，child才是我们预期的内容</div></App>
	    let node = wip.child;
	    while (node !== null) {
	        if (node.tag === HostComponent || node.tag === HostText) {
	            appendInitialChild(parent, node?.stateNode);
	        }
	        else if (node?.child !== null) {
	            // 向下找子节点
	            node.child.return = node;
	            node = node.child;
	            continue;
	        }
	        if (node === wip) {
	            // 最后向上回到了起点，结束
	            return;
	        }
	        while (node.sibling === null) {
	            if (node.return === null || node.return === wip) {
	                return;
	            }
	            // 如果没有兄弟节点，那么就向上返回
	            node = node?.return;
	        }
	        node.sibling.return = node.return;
	        node = node.sibling;
	    }
	}
	/**
	 * 副作用标记冒泡
	 * 构建 fiberNode 树之后，一部分节点会被标记，
	 * 如果再 DFS 找一次的话效率太低了，所以全部冒泡到父级上就可以了
	 */
	function bubbleProperties(wip) {
	    let subtreeFlags = NoFlags;
	    let child = wip.child;
	    while (child !== null) {
	        // 这一手操作，直接同时包含子节点的 flags 和 subtree flags，
	        // 这也就是为什么用离散的二进制表示不同的点
	        subtreeFlags |= child.subtreeFlags;
	        subtreeFlags |= child.flags;
	        // 这样就把同一层节点和它们的子树的副作用标签全部聚敛到父节点上了
	        child.return = wip;
	        child = child.sibling;
	    }
	    wip.subtreeFlags |= subtreeFlags;
	}
	/** 递归消费JSX的 归 阶段
	 *
	 * 需要构建一棵离屏的 DOM 树
	 */
	const completeWork = (wip) => {
	    // 比较，然后返回子 fiberNode
	    const newProps = wip.pendingProps;
	    const current = wip.alternate;
	    switch (wip.tag) {
	        case HostComponent:
	            if (current !== null && wip.stateNode) ;
	            else {
	                // mount 流程
	                // 构建 DOM
	                // const instance = createInstance(wip.type, newProps);
	                const instance = createInstance(wip.type);
	                // 优化，先构建离屏 DOM 树
	                appendAllChildren(instance, wip);
	                // 将 wip 及其下的整棵树 插入到 instance 中
	                wip.stateNode = instance;
	            }
	            bubbleProperties(wip);
	            return null;
	        case HostText:
	            if (current !== null && wip.stateNode) ;
	            else {
	                // mount
	                // 为啥这里插入文本不需要 appendAllChildren呢？
	                // 因为我们插入的其实是节点的child，文本没有child，可以直接插入
	                // 至于为什么是child而不是节点本身呢，这一点可以上面 appendAllChildren 的注释
	                const instance = createTextInstance(newProps.content);
	                wip.stateNode = instance;
	            }
	            bubbleProperties(wip);
	            return null;
	        case HostRoot:
	            bubbleProperties(wip);
	            return null;
	        default:
	            {
	                console.warn('未处理的completeWork的情况', wip);
	            }
	            break;
	    }
	};

	/** 全局指针，指向正在工作的 fiberNode */
	let workInProgress = null;
	/** 访问下一个兄弟节点, 如果不存在那么则访问父级节点，开始 归 */
	function completeUnitOfWork(fiber) {
	    let node = fiber;
	    do {
	        // 会对node进行重新赋值
	        completeWork(node);
	        const sibling = node.sibling;
	        if (sibling) {
	            workInProgress = sibling;
	            return;
	        }
	        node = node.return;
	    } while (node !== null);
	}
	/** 访问下一个 fiberNode，有子节点遍历子节点；没有子节点则遍历兄弟节点 */
	function performUnitOfWork(fiber) {
	    const next = beginWork(fiber);
	    fiber.memorizedProps = fiber.pendingProps;
	    if (next === null) {
	        // 子节点遍历结束，开始遍历兄弟节点
	        completeUnitOfWork(fiber);
	    }
	    else {
	        workInProgress = next;
	    }
	}
	/** 遍历 fiber 树: 循环调用 performUnitOfWork 方法访问下一个 fiberNode */
	function workLoop() {
	    while (workInProgress !== null) {
	        performUnitOfWork(workInProgress);
	    }
	}
	/** 初始化，指向需要遍历的第一个 fiberRootNode
	 *  也就是即将开始计算生成 fiber树——即初始化 workInProgress fiber 树
	 */
	function prepareFreshStack(fiberRootNode) {
	    // 初始化，所以 props 传空对象即可
	    workInProgress = createWorkInProgress(fiberRootNode.current);
	}
	/**
	 * 从当前 fiberNode 开始向上，找到并返回 fiberRootNode（指向了 fiber 树根节点的那个东西）
	 *
	 * hostRootFiber 的 return 值为 null（只有一个 stateNode 属性指向  fiberRootNode），
	 * 并且有个单独的类型叫 HostRoot
	 *
	 * 凭借这两点可以将其与普通的 fiberRootNode 区分
	 *
	 * */
	function markUpdateFromFiberToRoot(fiber) {
	    let node = fiber;
	    let parent = node.return;
	    while (parent) {
	        node = parent;
	        parent = node.return;
	    }
	    if (node.tag === HostRoot) {
	        return node.stateNode;
	    }
	    return null;
	}
	function commitRoot(fiberRootNode) {
	    const finishedWork = fiberRootNode.finishedWork;
	    if (finishedWork === null) {
	        return;
	    }
	    {
	        console.log('开始commit', finishedWork);
	    }
	    // 清空，类似于 git commit 之后清空暂存区
	    fiberRootNode.finishedWork = null;
	    // 处理Commit阶段的三个子阶段： beforeMutation mutation layout
	    // 通过 fiberRootNode flags subtreeFlags等属性
	    const subtreeHasEffect = (finishedWork.subtreeFlags & MutationMask) !== NoFlags;
	    const rootHasEffect = (finishedWork.flags & MutationMask) !== NoFlags;
	    if (subtreeHasEffect || rootHasEffect) {
	        // 1. beforeMutation阶段
	        // 2. mutation阶段
	        // 2.1 mutation阶段完成后，layout阶段开始前，双缓存树发生交换
	        commitMutationEffects(finishedWork);
	        fiberRootNode.current = finishedWork;
	        // 3. layout阶段
	    }
	    else {
	        // 即使没有更新发生，也需要有这么一个操作，保证其他流程的正确性
	        fiberRootNode.current = finishedWork;
	    }
	}
	/**
	 * 作用是执行更新。
	 * 触发更新时，就会调用这个方法。
	 * 触发更新的方法包括但不限于这些：
	 * 1. createRoot （老版本里面是 render)
	 * 2. useState的 dispatcher （老版本里面是 this.setState）
	 * 可以看出，触发更新的方式很多，所以就需要一个统一的、易扩展的更细方式：
	 * 1. 首先我们要有一个代表更新的数据结构，即 Update
	 * 2. 然后能消费这个它，消费它的数据结构就是 UpdateQueue (UpdateQueue.sharedPending = Update[])
	 * 这里也就是批处理的实现关键
	 */
	function renderRoot(fiberRootNode) {
	    // 生成 hostRootFiber 对应的 workInProgress hostRooFiber
	    prepareFreshStack(fiberRootNode);
	    // 正式进入 workLoop 的过程，开始更新
	    do {
	        try {
	            workLoop();
	            break;
	        }
	        catch (e) {
	            {
	                console.warn('workLoop出错', e);
	            }
	            workInProgress = null;
	        }
	    } while (true);
	    // 计算完成后的 workInProgress fiber 树
	    const finishedWip = fiberRootNode.current.alternate;
	    fiberRootNode.finishedWork = finishedWip;
	    // 执行具体的操作
	    commitRoot(fiberRootNode);
	}
	/**
	 *  开始调度，也承接了 reconcile。
	 *  会调用 markUpdateFromFiberToRoot，从当前 fiberNode 向上查找获取到 fiberRootNode
	 * 	然后从根节点开始计算新的 fiberNode 树
	 */
	function scheduleUpdateOnFiber(fiber) {
	    const fiberRootNode = markUpdateFromFiberToRoot(fiber);
	    renderRoot(fiberRootNode);
	}

	/** createRoot 方法底层调用的 API，在 Mount 阶段可能被调用，目的是创建 fiberRootNode
	 *
	 *  实现了 fiberRootNode 和 hostRootFiber 的互相指向：
	 *
	 * fiberRootNode.current === hostRootFiber
	 *
	 *  hostRootFiber.stateNode = fiberRootNode
	 * */
	function createContainer(container) {
	    const hostRootFiber = new FiberNode(HostRoot, {}, null);
	    const root = new FiberRootNode(container, hostRootFiber);
	    hostRootFiber.updateQueue = createUpdateQueue();
	    return root;
	}
	/** render 方法底层调用的 API，在 Mount 阶段可能被调用，
	 * 产生 update 对象并将其加入到 hostRootFiber 的 updateQueue 中
	 *
	 * (什么？你问为什么不是加入到 fiberRootNode 的 updateQueue?
	 * 很显然，因为 fiberRootNode 它并不是一个 fiberNode 类型，没有 updateQueue, 再去复习一下吧！)
	 *
	 *  更新完毕之后会调用 scheduleUpdateOnFiber 方法开启调度
	 *  实现了首屏渲染与触发更新后渲染的功能相连接
	 */
	function updateContainer(element, root) {
	    const hostRootFiber = root.current;
	    const update = createUpdate(element);
	    // 进入 updateQueue.ts 中
	    enqueueUpdate(hostRootFiber.updateQueue, update);
	    // 开始调度，进入 workLoop.ts
	    scheduleUpdateOnFiber(hostRootFiber);
	    return Element;
	}

	function createRoot(container) {
	    const root = createContainer(container);
	    return {
	        render(element) {
	            updateContainer(element, root);
	        }
	    };
	}

	var ReactDOM = /*#__PURE__*/Object.freeze({
		__proto__: null,
		createRoot: createRoot
	});

	return ReactDOM;

}));
